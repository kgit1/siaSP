create new Dynamic Web Project

	put libs to WebContent-> WEB-INF -> lib
	+ hibernate required libs 
	+ commons-dbcp for BasicDataSource
	+ commons-pool2 for connections pool for dataSource
	+ commons-logging
	+ mysql-connector-java
	
	test database

	create and populate MySql database 
	drop table if exists spittle;
	drop table if exists spitter;
	
	create table spitter (
	  id int not null auto_increment primary key,
	  username varchar(25) not null,
	  password varchar(25) not null,
	  fullname varchar(100) not null,
	  email varchar(50) not null,
	  update_by_email boolean not null
	);
	
	create table spittle (
	  id int not null auto_increment primary key,
	  spitter_id integer not null,
	  spittleText varchar(2000) not null,
	  postedTime date not null,
	  foreign key (spitter_id) references spitter(id)
	);
	
	alter table spitter add timestamp timestamp;
	alter table spitter add date timestamp;
	alter table spitter add time timestamp;
	
	insert into spitter (username, password, fullname, age, email, update_by_email) values 
	('habuma', 'password', 'Craig Walls', 19,'craig@habuma.com', false),
	('habum', 'password', 'Craig Wal', 21, 'ig@habuma.com', false),
	('habu', 'password', 'Cr Walls', 20, 'aig@habuma.com', false),
	('hab', 'password', 'Walls', 35,'raig@habuma.com', false);
	insert into spitter (username, password, fullname, age, email, update_by_email) values 
	('artnames', 'password', 'Art Names', 46,'artnames@habuma.com', false);
	
	insert into spittle (spitter_id, spittleText, postedTime) values 
	(1, 'Have you read Spring in Action 3? I hear it is awesome!', '2010-06-09');
	insert into spittle (spitter_id, spittleText, postedTime) values 
	(2, 'Trying out Spring''s new expression language.', '2010-06-11');
	insert into spittle (spitter_id, spittleText, postedTime) values 
	(1, 'Who''s going to SpringOne/2GX this year?', '2010-06-19');
	
	
	test database with simple connection in DbTest.class
	
	test database with hibernate connection in HibernateDbTest.classs
	put hibernate configuration with hibernate and database properties
	 - hibernate.cfg.xml to root src
	
	put spring context xml to WebContent-> WEB-INF
	
	at WebContent - create new jsp -> create index.jsp
	
	at index.jsp - put <% response.sendRedirect("home"); %>
	to make it redirecting to home.jsp mapped by "home" in controller
	
	at WebContent-> WEB-INF - create new folder view - to hold all our pages
	
	at WebContent create new folder - resources to hold our images and css
	so in WebContent-> resources - create folders images and css
	
	at Java Resources -> src - create packages for controllers, dao, services 
	and entity(model)

/////////////////////SPRING MVC///////////

	request from web page of our app will be handled in first by DIspatcherServlet,
	than he will found controller which fits to request,
	that controller will do work, than pack together model with procedure name 
	depends on which DispatcherServlet with help of resolver will found jsp 
	page on which data will be presented
	
	so first configure DespatcherServlet

	add web.xml to WebContent -> WEB-INF
	where we configure Dispatcher Servlet which manages all requests between view 
	and controller
	in which we assign welcome file and indicates where spring configuration is, 
	and maps "/" to be default path

	<?xml version="1.0" encoding="UTF-8"?>
	<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns="http://xmlns.jcp.org/xml/ns/javaee" 
	xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
	http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
	  <display-name>Spitter</display-name>
	
	  <welcome-file-list>
	    <welcome-file>index.jsp</welcome-file>
	    <welcome-file>index.html</welcome-file>
	  </welcome-file-list>
	
	  <servlet>
	    <servlet-name>dispatcher</servlet-name>
	    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	    <init-param>
	      <param-name>contextConfigLocation</param-name>
	      <param-value>/WEB-INF/appContext.xml</param-value>
	    </init-param>
	    <load-on-startup>1</load-on-startup>
	  </servlet>
	  
	  <servlet-mapping>
	    <servlet-name>dispatcher</servlet-name>
	    <url-pattern>/</url-pattern>
	  </servlet-mapping>
	</web-app>


	put libs to WebContent-> WEB-INF -> lib
	spring libs
	
	put spring context.xml to webContent -> WEB-INF
	assign this context.xml location in web.xml
	 <servlet>
	    <servlet-name>dispatcher</servlet-name>
	    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	    <init-param>
	      <param-name>contextConfigLocation</param-name>
	      <param-value>/WEB-INF/appContext.xml</param-value>
	    </init-param>
	    <load-on-startup>1</load-on-startup>
	  </servlet>


	in spring context.xml
	add tx namespace -transactions properties and annotations
	add mvc namespace - for SpringMVC properties and annotations

	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:context="http://www.springframework.org/schema/context"	
    xmlns:tx="http://www.springframework.org/schema/tx"    
	xmlns:mvc="http://www.springframework.org/schema/mvc"	
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context
		http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/mvc
		http://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx.xsd">

	<!-- Add support for component scanning -->
	<context:component-scan base-package="com.k1.spitter" />
	<!-- Add support for conversion, formatting and validation support -->
	<mvc:annotation-driven />

	<!-- Define Spring MVC view resolver -->
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/view/" />
		<property name="suffix" value=".jsp" />
	</bean>
	
	<!-- Step 1: Define Database DataSource / connection pool -->
	<!-- dataSource MySql connection -->
	<!-- we use dbcp BasicDataSource because it provides ability to use pool 
		of connections(c3p0 popular to) anlike as DriverManagerDataSource which just 
		create new connection every transaction -->
	<bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource"
		destroy-method="close">
		<property name="driverClassName" value="com.mysql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql//localhost:3306/spitter/spitter" />
		<property name="username" value="root" />
		<property name="password" value="123456" />
	</bean>

	<!-- Step 2: Setup Hibernate session factory -->
	<bean id="sessionFactory"
		class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<!-- dataSource - connection to database -->
		<property name="dataSource" ref="dataSource" />
		<!-- when all annotated classes would be searched in one package we can 
			not point each class, but just show package to scan -->
		<property name="packagesToScan" value="com.k1.spitter" />
		<property name="hibernateProperties">
			<props>
				<!-- tells hibernate which dialect use to talk with database -->
				<prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
				<!-- tells hibernate to show sql queries -->
				<prop key="hibernate.show_sql">true</prop>
			</props>
		</property>
	</bean>

	<!-- Step 3: Setup Hibernate transaction manager -->
	<!-- transactions for Hibernate -->
	<!-- transactionmanager default name for transaction managers, can be changed 
		if required, but better not -->
	<bean id="transactionManager"
		class="org.springframework.orm.hibernate5.HibernateTransactionManager">
		<!-- give session factory which will be wrapped by our transaction manager 
			to property "sessionFactory" -->
		<property name="sessionFactory" ref="sessionFactory" />
	</bean>

	<!-- Step 4: Enable configuration of transactional behavior based on annotations -->
	<tx:annotation-driven transaction-manager="myTransactionManager" />

	<mvc:resources location="/resources/" mapping="/resources/**"></mvc:resources>
	
	//////////////FIRST PAGE////////////
	create index.jsp in the Web-Content root 
	in Dispatcher Servlet we define it as welcome-page
	on index.jsp we create redirect to first page of our app
	<% response.sendRedirect("home"); %>
	
	create HomeController for our first page
	@GetMapping("/home")
	public String home() {
		return "home";
	}
	
	add links on first page to our other pages like "list" and "registration"
	
	////////////////LIST///////////////
	
	create new controller to map jsp page with list
	
	@Transactional
	// get spitters list and send it to page by adding as attribute to model
	@GetMapping("/home/list")
	public String printList(Model theModel) {
		// get current hibernate session
		Session session = factory.getCurrentSession();

		// get spitters from db
		List<Spitter> spitters = session.createQuery("from Spitter").getResultList();

		// add spitters list to model which will go to return page
		theModel.addAttribute("spitters", spitters);
		// lead to list page
		return "pages/list";
	}
	
	add jstl libs to WebContent-> WEB-INF -> lib
	add <!-- add jstl tags namespace  -->
	<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>   
	to begining of jsp page
	
	add table to recreate look of our db table on list page
	
	<p6>LIST HERE</p6>
	<hr>
	<table>
		<tr>
			<th>ID</th>
			<th>UserName</th>
			<th>FullName</th>
			<th>Age</th>
			<th>Creation/Update</th>
			<th>UPDATE</th>
			<th>DELETE</th>
			<th>INFO</th>
		</tr>

		<!-- foreach iterator which will iterate through list "spitters" 
		sended by adding attribute to model 
		items="${spitters} <- customers name from MVC theModel-->
		<c:forEach var="spitter" items="${spitters}">
			<tr>

				<!-- construct an "udpate" link with customer id --->
				<!--var - variable name to use somewhere,--->
				<!--value - urlpath which will be given,--->
				<!--c:param name - name of parameter added to model,--->
				<!--value - value of parameter added to model, in our case - spitter's id--->
				<c:url var="updateLink" value="/showFormForUpdate">
					<c:param name="spitterId" value="${spitter.id}" />
				</c:url>

				<c:url var="deleteLink" value="/delete">
					<c:param name="spitterId" value="${spitter.id}" />
				</c:url>

				<c:url var="fullInfo" value="/info">
					<c:param name="spitterId" value="${spitter.id}" />
				</c:url>

				<%-- <td>Spitter ID: <c:out value="${spitter.id}"/></td> --%>
				<td>${spitter.id}</td>
				<!-- will call spitters.getUserName() -->
				<td>${spitter.userName}</td>
				<!-- will call spitters.getFullName() -->
				<td>${spitter.fullName}</td>
				<!-- will call spitter.getAge() -->
				<td>${spitter.age}</td>
				<!-- will call spitters.getTimestamp() -->
				<td>${spitter.date}</td>

				<!-- display the update and delete link -->
				<!-- will call updateLink variable from this page -->
				<td><a href="${updateLink}">UPDATE</a></td>
				<!-- will call deleteLink variable from this page -->
				<td><a href="${deleteLink}"
					onclick="if(!(confirm('Are you sure you want to delete this 
					customer?'))) return false">DELETE</a></td>
				<!-- will call fullInfo variable from this page -->
				<td><a href="${fullInfo}">INFO</a></td>
			</tr>
		</c:forEach>
	</table>
	
	
////////////////REGISTRATION/////////////
	
	create registration jsp
	
	create controller which redirects to registration page and sends empty 
	spitter object
	@GetMapping("reg")
	public String reg(Model theModel) {
		Spitter spitter = new Spitter();
		theModel.addAttribute("spitter",spitter);
		return "pages/reg";
	}
	
	add to the registration jsp for form namespace
	 <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
	 
	 add to header 
	<title>${spitter.userName} ${spitter.fullName}</title>
	
	add form to hold table with inputs and submit buttons and fields
	
	<!-- on form load - spring will execute getters to populate fields -->
	<!-- on form submit - spring will use setters to change field's values -->
	<form:form action="saveSpitter" modelAttribute="spitter" method="POST">
	
	<!-- need to associate this data with customer id, when we use this form 
	to update current customer -->
	<form:hidden path="id"/>
	
		<table>
			<tbody>
				<tr>
					<td><label>UserName</label></td>
					<td><form:input path="userName" /></td>
				</tr>
				<tr>
					<td><label>FullName</label></td>
					<td><form:input path="fullName" /></td>
				</tr>
				<tr>
					<td><label>Age</label></td>
					<td><form:input path="age"/></td>
				<tr>
					<td><label>Password</label></td>
					<td><form:password path="password" /></td>
				</tr>
				<tr>
					<td><label>Email</label></td>
					<td><form:input path="email" /></td>
				</tr>
				<tr>
					<td><label></label></td>
					<td><input type="submit" value="Save" /></td>
				</tr>
			</tbody>
		</table>
	</form:form>
	
	add save controller which save spitter to db and redirect us 
	to spitters list
	@Transactional
	@PostMapping("/saveSpitter")
	public String saveSpitter(@ModelAttribute("spitter") Spitter spitter) {
		// get current hibernate session
		Session session = factory.getCurrentSession();
		// save or update
		session.saveOrUpdate(spitter);
		// redirect to list page, redirect will recreate page with new
		// independent model
		return "redirect:/home/list";
	}
	
	
////////////////BUTTONS///////////////
	
	add update, delete, and search buttons to "list" page
	
	to create update and delete buttons in list, which will use spitter.id to
	define affected spitter - we use c:url	
	<c:url> JSTL tag is used for url formatting or you can say url encoding. 
	This is mainly used when we need to open a JSP page based on the user 
	input or based on the value of a variable.
	
	<!-- construct an "udpate" link with customer id --->
		<!--var - variable name to use somewhere,--->
		<!--value - urlpath which will be given,--->
		<!--c:param name - name of parameter added to model,--->
		<!--value - value of parameter added to model, in our case - spitter's id--->
		<c:url var="updateLink" value="spitter/showFormForUpdate">
			<c:param name="spitterId" value="${spitter.id}" />
		</c:url>

		<c:url var="deleteLink" value="spitter/delete">
			<c:param name="spitterId" value="${spitter.id}" />
		</c:url>
		
	and than create buttons in table  depending on this created url's
		<!-- display the update and delete link -->
		<!-- will call updateLink variable from this page -->
		<td><a href="${updateLink}">UPDATE</a> | <!-- will call updateLink 
		variable from this page -->
			<a href="${deleteLink}">DELETE</a></td>
			
	than create controllers to use this buttons
	
	@Transactional
	@GetMapping("showFormForUpdate")
	// here we sent to method parameter id, requesting it from model by
	// @RequestParam("spitterId") int id
	public String showFormForUpdate(@RequestParam("spitterId") int id, Model 
	theModel) {
		// get current hibernate session
		Session session = factory.getCurrentSession();

		// create spitter and transfer certain spitter from db, received by id
		Spitter spitter = session.get(Spitter.class, id);
		// set timestamp time and date in our spitter to null, because they
		// automatically created by db
		spitter.setTimestamp(null);
		spitter.setTime(null);
		spitter.setDate(null);

		// add spitter as attribute to model by addAttribute() method which
		// requests as params - objects name in model and object
		theModel.addAttribute("spitter", spitter);

		// lead us with model next to reg page
		return "pages/reg";
	}
	
	
//////////////////SINGLE SPITTER/////////////////
	
	create new jsp page for single spitter with full info
	
	add <!-- add jstl tags namespace  -->
	<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>   
	to begining of jsp page
	
	add to header 
	<title>${spitter.userName} ${spitter.fullName}</title>
	
	add table to represent spitter's info
	
		<table>
		<tr>
			<th>ID</th>
			<th>UserName</th>
			<th>FullName</th>
			<th>Age</th>
			<th>Password</th>
			<th>Email</th>
			<th>EmailUpdate</th>
			<th>Creation/Update date</th>
			<th>Creation/Update time</th>
			<th>Creation/Update date+time</th>
			<th>Update</th>
			<th>Delete</th>
		</tr>
		<tr>
			<c:url var="updatelink" value="/showFormForUpdate">
				<c:param name="spitterId" value="${spitter.id}" />
			</c:url>
			<c:url var="deletelink" value="/delete">
				<c:param name="spitterId" value="${spitter.id}" />
			</c:url>
			<%-- <td>Spitter ID: <c:out value="${spitter.id}"/></td> --%>
			<td>${spitter.id}</td>
			<!-- will call spitters.getUserName() -->
			<td>${spitter.userName}</td>
			<!-- will call spitters.getFullName() -->
			<td>${spitter.fullName}</td>
			<!-- will call spitter.getAge() -->
			<td>${spitter.age}</td>
			<!-- will call spitters.getPassword() -->
			<td>${spitter.password}</td>
			<!-- will call spitters.getEmail() -->
			<td>${spitter.email}</td>
			<!-- will call spitters.getUpdateByEmail() -->
			<td>${spitter.updateByEmail}</td>
			<!-- will call spitters.getTimestamp() -->
			<td>${spitter.date}</td>
			<!-- will call spitters.getTimestamp() -->
			<td>${spitter.time}</td>
			<!-- will call spitters.getTimestamp() -->
			<td>${spitter.timestamp}</td>

			<!-- display the update and delete link -->
			<!-- will call updateLink variable from this page -->
			<td><a href="${updateLink}">UPDATE</a></td>
			<!-- will call deleteLink variable from this page -->
			<td><a href="${deleteLink}"
				onclick="if(!(confirm('Are you sure you want to delete this 
				customer?'))) return false">DELETE</a></td>
		</tr>
	</table>
	
	add controller to handle this page
	@Transactional
	@GetMapping("info")
	public String fullInfoOnSpitter(@RequestParam("spitterId") int id, Model 
	theModel) {
		Session session = factory.getCurrentSession();
		Spitter spitter = session.get(Spitter.class, id);
		theModel.addAttribute("spitter", spitter);
		return "pages/spitterFullInfo";
	}
	
	
///////////TILES//////////////////////
	
	add tiles libs to WebContent-> WEB-INF -> lib
	+slf4j-api-1.7.6
	+commons-beanutils-1.8.0
	+commons-digester-2.0
	+jcl-over-slf4j-1.7.6
	
	add tiles beans to appContext.xml
	
	<!-- Step 6: Setup tiles -->
	<!-- add tiles viewResolver, and don't forget to comment SpringMvc 
	viewResolver, because they can't work together-->
	<bean id="viewResolver"  
        class="org.springframework.web.servlet.view.UrlBasedViewResolver">  
        <property name="viewClass">  
            <value>  
                org.springframework.web.servlet.view.tiles2.TilesView  
            </value>  
        </property>  
    </bean>
      
    <bean id="tilesConfigurer"  
        class="org.springframework.web.servlet.view.tiles2.TilesConfigurer">  
        <property name="definitions">  
            <list>  
                <value>/WEB-INF/tiles.xml</value>  
            </list>  
        </property>  
    </bean>  
    
    add tiles.xml at Web-Content-> WEB-INF root
    
    add to tiles.xml
    
	<?xml version="1.0" encoding="UTF-8" ?>  
	<!DOCTYPE tiles-definitions PUBLIC
	  "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN" 
	  "http://tiles.apache.org/dtds/tiles-config_3_0.dtd">
	
	<tiles-definitions>
	
		<!-- Base Definition -->
		<definition name="base.definition" template="/WEB-INF/view/tiles/layout.jsp">
			<put-attribute name="title" value="" />
			<put-attribute name="header" value="/WEB-INF/view/tiles/aHeader.jsp" />
			<put-attribute name="left" value="/WEB-INF/view/tiles/aLeft.jsp" />
			<put-attribute name="body" value="" />
			<put-attribute name="right" value="/WEB-INF/view/tiles/aRight.jsp" />
			<put-attribute name="footer" value="/WEB-INF/view/tiles/aFooter.jsp" />
		</definition>
	
		<!-- List Page -->
		<definition name="home" extends="base.definition">
			<put-attribute name="title" value="Home" />
			<put-attribute name="body" value="/WEB-INF/view/home.jsp" />
		</definition>
	
		<!-- List Page -->
		<definition name="pages/list" extends="base.definition">
			<put-attribute name="title" value="List Of Spitters" />
			<put-attribute name="body" value="/WEB-INF/view/pages/list.jsp" />
		</definition>
	
		<!-- Reg Page -->
		<definition name="pages/reg" extends="base.definition">
			<put-attribute name="title" value="Spitter page" />
			<put-attribute name="body" value="/WEB-INF/view/pages/reg.jsp" />
		</definition>
	
		<!-- SpitterFull Page -->
		<definition name="pages/spitterFullInfo" extends="base.definition">
			<put-attribute name="title" value="Spitter page" />
			<put-attribute name="body" value="/WEB-INF/view/pages/spitterFullInfo.jsp" />
		</definition>
	
	</tiles-definitions>  

	add layout.jsp to WebContent-> WEB-INF-> view-> tiles
	to configure tiles disposal
		
		<%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="tiles"%>
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
	"http://www.w3.org/TR/html4/loose.dtd">
	<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title><tiles:insertAttribute name="title" ignore="true" /></title>
	<link rel="stylesheet" type="text/css"
		href="${pageContext.request.contextPath}/resources/css/tiles.css">
	</head>
	
	<body>
		<div class="wrap">
			<div class="tilesHeader">
				<tiles:insertAttribute name="header" />
			</div>
	
			<div class="center">
				<div class="tilesLeft">
					<tiles:insertAttribute name="left" />
				</div>
	
				<div class="tilesBody">
					<tiles:insertAttribute name="body" />
				</div>
	
				<div class="tilesRight">
					<tiles:insertAttribute name="right" />
				</div>
			</div>
			<div class="tilesFooter">
				<tiles:insertAttribute name="footer" />
			</div>
		</div>
	
	</body>
	</html>
	
	
		add aHeader, aLeft, aRight, aBottom jsps 
		to WebContent-> WEB-INF-> view-> tiles
		
		add tiles.css to WebContent-> resources-> css
	
		html, .container {
		height: 100%;
	}
	
	body {
		background: green;
	/* 	margin:0 auto 0 auto; */
	}
	
	.wrap{
		width: 1200px;
	/* 	float:left; */
	/* 	height:auto; */
		margin:0 auto 0 auto;
	}
	.center {
		min-height: 800px; height : 100%;
		background: aqua;
		overflow: hidden;
		height: 100%;
		margin: 0 auto 0 auto;
	/* 	margin:5px; */
	}
	
	.tilesHeader {
		height: 100px;
		border: solid pink 2px;
		margin: 5px;
		padding: 4px;
		background: red;
	}
	
	.tilesLeft {
		width: 167px;
		min-height: 800px;
		height: 100%;
		border: solid pink 2px;
		margin: 5px;
		padding: 4px;
		background: orange;
		float: left;
		background: orange;
		overflow: auto;
	}
	
	.tilesBody {
		width: 700px;
		min-height: 800px;
		overflow: auto;
		border: solid pink 2px;
		margin: 5px;
		padding: 4px;
		float: left;
		margin: 5px;
		border: solid pink 2px;
	}
	
	.tilesRight {
		width: 267px;
		min-height: 800px;
		height: 100%;
		border: solid pink 2px;
		margin: 5px;
		padding: 4px;
		background: yellow;
		position: relative;
		float: right;
	}
	
	.tilesFooter {
		height: 200px;
		border: solid pink 2px;
		margin: 5px;
		padding: 4px;
		background: blue;
		clear: both;
	}


////////////////////LOGGING SQL//////////////

	Question
	There are many developers asking about Hibernate SQL parameter value 
	question. How to display the Hibernate SQL parameter values that passed 
	to database? Hibernate just display all parameter values as question 
	mark (?). With show_sql property, Hibernate will shows all generated 
	SQL statements, but not the SQL parameter values.
	
	For example
	
	Hibernate: insert into mkyong.stock_transaction (CHANGE, CLOSE, DATE, OPEN, STOCK_ID, VOLUME)
	values (?, ?, ?, ?, ?, ?)
	Is there a way to log or display the exact Hibernate SQL parameter values?
	
	Solution – P6Spy
	Well, if there is a question there is an answer ~
	
	The P6Spy is a useful library to log all SQL statement and parameter values 
	before send it to database. The P6Spy is free, it’s use to intercepts 
	and logs all your database SQL statements into a log file, and it works 
	for any application that uses JDBC driver.
	
	1. Download P6Spy library
	Get the “p6spy-install.jar“, you can download it from
	
	P6Spy official website.
	P6Spy at Sourceforge.net
	2. Extract it
	Extract the p6spy-install.jar file, look for p6spy.jar and spy.properties
	
	3. Add library dependency
	Add p6spy.jar into your project library dependency
	
	4. Modify P6Spy properties file
	Modify your database configuration file. You need to replace your existing 
	JDBC driver with P6Spy JDBC driver – ” com.p6spy.engine.spy.P6SpyDriver”
	
	Original is MySQL JDBC driver – “com.mysql.jdbc.Driver”
	
	<session-factory>
	  <property name="hibernate.bytecode.use_reflection_optimizer">false</property>
	  <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
	  <property name="hibernate.connection.password">password</property>
	  <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/mkyong</property>
	  <property name="hibernate.connection.username">root</property>
	  <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
	  <property name="show_sql">true</property>
	</session-factory>
	Changed it to P6Spy JDBC driver – “com.p6spy.engine.spy.P6SpyDriver”
	
	<session-factory>
	  <property name="hibernate.bytecode.use_reflection_optimizer">false</property>
	  <property name="hibernate.connection.driver_class">com.p6spy.engine.spy.P6SpyDriver
	  </property>
	  <property name="hibernate.connection.password">password</property>
	  <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/mkyong</property>
	  <property name="hibernate.connection.username">root</property>
	  <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
	  <property name="show_sql">true</property>
	</session-factory>
	5. Modify P6Spy properties file
	Modify the P6Spy properties file – “spy.properties”
	
	Replace the “real driver” with your existing MySQL JDBC driver
	
	realdriver=com.mysql.jdbc.Driver
	
	#specifies another driver to use
	realdriver2=
	#specifies a third driver to use
	realdriver3=
	Change the Log file location
	Change the log file location in logfile property, all SQL statements will 
	log into this file.
	
	Windows
	
	logfile     = c:/spy.log
	*nix
	
	logfile     = /srv/log/spy.log
	6. Copy “spy.properties” to project classpath
	Copy “spy.properties” to your project root folder, make sure your project 
	can locate “spy.properties”, else it will prompt “spy.properties” file 
	not found exception.
	
	7. Done
	Run your application and do some database transaction, you will notice 
	all the SQL statements sent from application to database will be logged 
	into a file you specified in “spy.properties”.
	
	Sample log file as following.
	
	insert into mkyong.stock_transaction (CHANGE, CLOSE, DATE, OPEN, STOCK_ID, VOLUME)
	values (?, ?, ?, ?, ?, ?)|
	insert into mkyong.stock_transaction (CHANGE, CLOSE, DATE, OPEN, STOCK_ID, VOLUME)
	values (10.0, 1.1, '2009-12-30', 1.2, 11, 1000000)
	Conclusion
	Frankly, the P6Spy is really useful in reducing the developers’ debugging 
	time. As long as your project is using JDBC driver for connection , P6Sqp 
	can fir into it and log all SQL statements and parameter values for you.
	
	For Maven User
	You can use Maven to download the P6Spy dependency into your pom.xml
	
	<dependency>
		<groupId>p6spy</groupId>
		<artifactId>p6spy</artifactId>
		<version>1.3</version>
	</dependency>


////////////////VALIDATION DATA/////////////////

	add validation libs to WebContent-> WEB-INF -> lib 
		+validation-api-1.1.0.Final
		+hibernate-validator-5.4.0.Final
		+hibernate-validator-annotation-processor-5.4.0.Final
		+hibernate-validator-cdi-5.4.0.Final
	
	add to appContext.xml
	<bean id="validator" 
	class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean" />
	
	add validation parameters to Entity class with 
	@NotNull @Size @Min @Max @Pattern etc like 
	
	@Column(name = "username", unique = true)
	@NotNull(message = "Can't be empty")
	@Size(min = 3, max = 20, message = "Username must be between 3 and 20 
	characters long")
	@Pattern(regexp = "^[a-zA-Z0-9]+$", message = "Username must be 
	alphanumeric with no spaces")
	private String userName;

	@Column(name = "password")
	@Size(min = 6, max = 9, message = "Password must be at least 6 characters 
	long, and not longer than 20")
	private String password;

	@Column(name = "fullname")
	@Size(min = 3, max = 50, message = "YOur full name must be between 3 and 
	50 characters long")
	private String fullName;

	@Column(name = "age")
	@NotNull(message = "Can't be 0")
	@Min(18)
	private int age;

	@Column(name = "email")
	@Pattern(regexp = "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}", 
	message = "Invalid email address")
	private String email;
	
    
    add validation to controller with help of @Valid and BindingResults class 
    Simply adding `@Valid` tells Spring to validate the object.  
    Notice we also add a “BindingResult” argument. This is Spring’s object 
    that holds the result of the validation and binding and contains errors 
    that may have occurred. The BindingResult must come right after the model 
    object that is validated or else Spring will fail to validate the object 
    and throw an exception.
	When Spring sees “@Valid”, it tries to find the validator for the object 
	being validated. Spring automatically picks up validation annotations if 
	you have “mvc:annotation-driven” enabled. Spring then invokes the validator 
	and puts any errors in the BindingResult and adds the BindingResult to 
	the view model.
    
    @Transactional
	@PostMapping("/saveSpitter")
		public String saveSpitter(@Valid @ModelAttribute("spitter")  Spitter 
		spitter, BindingResult bindingResult) {
		
		if(bindingResult.hasErrors()){
			return "pages/reg";
		}
		
		// get current hibernate session
		Session session = factory.getCurrentSession();
		// save or update
		session.saveOrUpdate(spitter);
		// redirect to list page, redirect will recreate page with new
		// independent model
		return "redirect:/home/list";
	}
	
	
	add errors to jsp.page with <form:errors> - is used to display 
	BindingResult in JSP
	If we use
	<form:errors path="fieldName" cssClass="error"/>
	then it will display field specific error and if we use <form:errors/> 
	without field name, it will display all errors.
	
	<form:form action="saveSpitter" modelAttribute="spitter" method="POST">
		<table>

			<!-- need to associate this data with customer id, when we use 
			this form 
	to update current customer -->
			<form:hidden path="id" />
			<form:errors path="*" cssClass="error" />
			<%-- 			<form:errors path="*" cssClass="error" element=
			"error"/> --%>
			<tbody>
				<tr>
					<td><label>UserName</label></td>
					<td><form:input path="userName" /></td>
					<td><form:errors path="userName" cssClass="error" /></td>
				</tr>
				<tr>
					<td><label>FullName</label></td>
					<td><form:input path="fullName" /></td>
					<td><form:errors path="fullName" cssClass="error" /></td>
				</tr>
				<tr>
					<td><label>Age</label></td>
					<td><form:input path="age" /></td>
					<td><form:errors path="age" cssClass="error" /></td>
				<tr>
					<td><label>Password</label></td>
					<td><form:password path="password" /></td>
					<td><form:errors path="password" cssClass="error" /></td>
				</tr>
				<tr>
					<td><label>Email</label></td>
					<td><form:input path="email" /></td>
					<td><form:errors path="email" cssClass="error" /></td>
				</tr>
				<tr>
					<td><label></label></td>
					<td><input type="submit" value="Save" /></td>
				</tr>
			</tbody>
		</table>
	</form:form>
	
	This is nice, but does not support internationalization. Plus, do we really
	 want our messages in our Java objects? Fortunately, we can easily override 
	 the default messages in our message bundle. To do this, first set up 
	 a message bundle:

	JavaConfig:
	@Bean
	public MessageSource messageSource() {
	    ResourceBundleMessageSource messageSource = 
	    new ResourceBundleMessageSource();
	    messageSource.setBasename("messages");
	    return messageSource;
	}
	XML Config:
	<bean id="messageSource" 
	class="org.springframework.context.support.ResourceBundleMessageSource">
	    <property name="basename" value="messages"/>
	</bean>
	Now, create a file called “messages.properties” in “src/main/resources”. 
	Now, we can override the default error messages. Error messages are 
	resolved using the following pattern:
	
	{ValidationClass}.{modelObjectName}.{field}
	For example, if the age field of our “subscriber” model object fails 
	the “NotNull” validation, the “NotNull.subscriber.age” message would 
	be looked up. If the message isn’t found, “NotNull.subscriber” would be 
	looked for. Finally, if not found, “NotNull” message would be looked for. 
	If that also isn’t found, the default message (what we saw above) would be 
	rendered. With this convention in mind, let’s define our error messages:
	
	Size=the {0} field must be between {2} and {1} characters long
	Size.subscriber.name=Name must be between {2} and {1} characters
	Size.subscriber.phone=Phone must be at least {2} characters
	 
	Min.subscriber.age=You must be older than {1}
	Max.subscriber.age= Sorry, you have to be younger than {1}
	 
	Email=Email address not valid
	Past=Date must be in the past
	 
	NotEmpty=Field cannot be left blank
	NotNull=Field cannot be left blank
	 
	typeMismatch=Invalid format
	methodInvocation.myRequest.amount=Invalid format
	Notice the use of {0}, {1}, etc. These are arguments that can be passed in to the message.
	 

/////////////////MULTIPLE VIEW RESOLVER////////////

	to add multiple view resolvers just add resolvers one by one
	but to every add 
	<property name="order" value="0"/>
	where value will define order in which spring will invoke resolvers, if
	spring don't see resolver to use with first priority, he will try
	next in line
	
	
	
	
	
